import pathlib
from typing import List, Union, Optional

import numpy as np
import pandas as pd
from patsy import dmatrix

from icare import utils, check_errors


def check_population_design_matrix(population_distribution: pd.DataFrame, log_relative_risk: dict) -> None:
    if not set(population_distribution.columns).issubset(set(log_relative_risk.keys())):
        print(f"'model_reference_dataset' design matrix columns: {population_distribution.columns}")
        print(f"'model_log_relative_risk' keys: {log_relative_risk.keys()}")
        raise ValueError("ERROR: the column names 'model_reference_dataset' design matrix generated by the "
                         "Patsy formula 'model_covariate_formula', must exist as covariate keys in the "
                         "'model_log_relative_risk' input dictionary.")


class CovariateModel:
    """A general-purpose covariate model."""
    age_start: Union[int, List[int]]
    age_interval_length: Union[int, List[int]]
    beta_estimates: np.ndarray
    z_profile: pd.DataFrame
    population_distribution: pd.DataFrame
    population_weights: np.ndarray

    def __init__(
            self,
            formula_path: Union[str, pathlib.Path, None],
            log_relative_risk_path: Union[str, pathlib.Path, None],
            reference_dataset_path: Union[str, pathlib.Path, None],
            profile_path: Union[str, pathlib.Path, None],
            reference_dataset_weights: Optional[List[float]],
            age_start: Union[int, List[int]],
            age_interval_length: Union[int, List[int]]) -> None:
        parameters = [formula_path, log_relative_risk_path, reference_dataset_path, profile_path]
        any_parameter_missing = any([x is None for x in parameters])

        if any_parameter_missing:
            raise ValueError("ERROR: Either all or none of the covariate parameters— 'model_covariate_formula', "
                             "'model_log_relative_risk', 'model_reference_dataset', and 'apply_covariate_profile'"
                             "— should be specified. If none of them are specified, it implies the special option "
                             "for a SNP-only model.")

        formula = utils.read_file_to_string(formula_path)
        log_relative_risk = utils.read_file_to_dict(log_relative_risk_path)
        reference_dataset = utils.read_file_to_dataframe(reference_dataset_path)
        profile = utils.read_file_to_dataframe(profile_path)

        self.age_start, self.age_interval_length = utils.set_age_intervals(
            age_start, age_interval_length, profile, "apply_covariate_profile"
        )

        check_errors.check_covariate_parameters(log_relative_risk, reference_dataset, profile)
        self.set_population_distribution(formula, reference_dataset, log_relative_risk)
        self.set_population_weights(reference_dataset_weights, reference_dataset)
        # set profile
        # check reference and profile

    def set_population_weights(
            self,
            reference_dataset_weights: Optional[List[float]],
            reference_dataset: pd.DataFrame) -> None:
        if reference_dataset_weights is None:
            self.population_weights = np.ones(len(reference_dataset)) / len(reference_dataset)
        else:
            check_errors.check_population_weights(reference_dataset_weights, reference_dataset)
            self.population_weights = np.array(reference_dataset_weights) / sum(reference_dataset_weights)

    def set_population_distribution(
            self,
            formula: str,
            reference_dataset: pd.DataFrame,
            log_relative_risk: dict) -> None:
        population_distribution = dmatrix(formula, reference_dataset, return_type="dataframe")
        population_distribution = population_distribution.drop(columns=["Intercept"])
        check_population_design_matrix(population_distribution, log_relative_risk)
        self.population_distribution = population_distribution
